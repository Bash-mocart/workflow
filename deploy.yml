# jobs:
#   deploy-staging:
#     name: 'deploy-staging'
#     runs-on: ubuntu-latest
#   on:
#     workflow_call:
#       inputs:
#         username:
#           required: true
#           type: string


#     # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
#     defaults:
#       run:
#         shell: bash
    
#     env:
#       DOCKER_REPOSITORY: bashox
#       FRONTEND_IMAGE_NAME: revolgy-frontend
#       BACKEND_IMAGE_NAME: revolgy-backend
#       IMAGE_TAG: ${{ github.run_number }}
#       CLUSTER_NAME: eks
    
#     steps:
#     # Checkout the repository to the GitHub Actions runner
#     - name: Checkout
#       # if: github.event_name == 'pull_request'
#       uses: actions/checkout@v3

#     - name: Configure AWS Credentials
#       uses: aws-actions/configure-aws-credentials@v1
#       with:
#         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#         aws-region: ${{ secrets.AWS_REGION}}

    
#     # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v1
#       with:
#         cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
#         terraform_wrapper: false

#     - name: Terraform Init
#       id: init
#       run: |
#         terraform -chdir=./staging init
    


#     # Checks that all Terraform configuration files adhere to a canonical format
#     - name: Terraform Format
#       id: format
#       run: |
#         terraform -chdir=./staging fmt -check 

#     # validating the terraform code for any syntax error
#     - name: Terraform validate
#       id: validate
#       run: | 
#           terraform -chdir=./staging validate
    
#     - name: Terraform Apply
#       run: |
#           terraform -chdir=./staging apply -auto-approve
  
#     - name: Updating kubeconfig
#       run: aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }}

  
#     - name: Eksctl, kubectl, helm tool installer
#       run: |
#           chmod +x install-helm-eksctl-kubectl.sh
#           ./install-helm-eksctl-kubectl.sh

#     - name: Configuring alb
#       run: |
#         eksctl utils associate-iam-oidc-provider \
#           --region ${{ secrets.AWS_REGION}} \
#           --cluster ${{ env.CLUSTER_NAME }} \
#           --approve

#     - name: configuring policy
#       continue-on-error: true
#       run: |
#         curl -o iam-policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.2.1/docs/install/iam_policy.json
#         aws iam create-policy \
#           --policy-name AWSLoadBalancerControllerIAMPolicy \
#           --policy-document file://iam-policy.json

#     - name: creating service account
#       run: |
#         eksctl create iamserviceaccount \
#           --cluster=${{ env.CLUSTER_NAME }} \
#           --namespace=kube-system \
#           --name=aws-load-balancer-controller \
#           --attach-policy-arn=arn:aws:iam::${{ secrets.ACCOUNT_ID }}:policy/AWSLoadBalancerControllerIAMPolicy \
#           --override-existing-serviceaccounts \
#           --approve

#     - name: helm install alb
#       run: |  
#         helm repo add eks https://aws.github.io/eks-charts
#         kubectl apply -k "github.com/aws/eks-charts/stable/aws-load-balancer-controller//crds?ref=master"
#         helm upgrade -i aws-load-balancer-controller eks/aws-load-balancer-controller -n kube-system --set clusterName=${{ env.CLUSTER_NAME }} --set serviceAccount.create=false --set serviceAccount.name=aws-load-balancer-controller

    
#     - name: Installing prometheus, grafana
#       run: | 
#           chmod +x install-alb-prom-graf.sh
#           ./install-alb-prom-graf.sh
          
#           helm upgrade -i grafana grafana/grafana \
#             --namespace grafana \
#             --set persistence.storageClassName="gp2" \
#             --set persistence.enabled=true \
#             --set adminPassword=${{ secrets.GRAFANA_PASS }} \
#             --values grafana.yaml \
#             --set service.type=LoadBalancer


#     - name: deploying application
#       run: |
#           echo starting
#           export DNS_NAME=$(terraform -chdir=./staging output -raw postgresdns)
#           cd helm
#           helm upgrade -i revolgy revolgy \
#             --set database.DNS=$DNS_NAME \
#             --set frontend.containerImage=${{ env.DOCKER_REPOSITORY }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }} \
#             --set backend.container.Image=${{ env.DOCKER_REPOSITORY }}/${{ env.BACKEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }} \
#             --set backend.container.TYPEORM_CONNECTION=${{ secrets.TYPEORM_CONNECTION }} \
#             --set backend.container.TYPEORM_MIGRATIONS_DIR=${{ secrets.TYPEORM_MIGRATIONS_DIR }} \
#             --set backend.container.TYPEORM_MIGRATIONS=${{ secrets.TYPEORM_MIGRATIONS }} \
#             --set backend.container.TYPEORM_PORT=${{ secrets.TYPEORM_PORT }} \
#             --set backend.container.TYPEORM_PASSWORD=${{ secrets.TYPEORM_PASSWORD }} \
#             --set backend.container.TYPEORM_USERNAME=${{ secrets.TYPEORM_USERNAME }} \
#             --set backend.container.TYPEORM_DATABASE=${{ secrets.TYPEORM_DATABASE }} 

#     - name: Run Kube-Bench to check cluster config
#       continue-on-error: true
#       run: |
#         kubectl apply -f https://raw.githubusercontent.com/aquasecurity/kube-bench/main/job-aks.yaml
#         sleep 30s
#         kubectl logs job.batch/kube-bench
#         kubectl delete job.batch/kube-bench